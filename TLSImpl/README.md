# TLSImpl

A client program written in Kotlin that implements the TLS (v1.2) protocol.

## Target

Generate a master key by implement TLS handshake. And use the key to communicate with the server.

```
Client                                    Server

ClientHello       -------->
                                     ServerHello
                                    Certificate*
                              ServerKeyExchange*
                             CertificateRequest*
                  <--------      ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished          -------->
                              [ChangeCipherSpec]
                  <--------             Finished
Application Data  <------->     Application Data
```

## Client Flow

- [x] Client Hello
- [x] Client Key Exchange
- [x] Change Cipher Spec
- [ ] Finished

## Handle Server Flow Parse

- [x] Server Hello
- [x] Certificate
- [x] ServerKeyExchang
- [x] ServerHelloDone
- [ ] ChangeCipherSpec
- [ ] Finished


## Term

### Secret

#### premaster secret

https://tools.ietf.org/html/rfc5246#section-7.4.7


Two way to generate premaster secret: With `Client Key Exchange` message, the premaster secret is set, either by direct transmission of the RSA-encrypted secret or by the transmission of Diffie-Hellman parameters that will allow each side to agree upon the same premaster secret.

1. RSA

When RSA is used for server authentication and key exchange, a 48-byte pre_master_secret is generated by the client, encrypted under the server's public key, and sent to the server.  The server uses its private key to decrypt the pre_master_secret.  Both parties then convert the pre_master_secret into the master_secret, as specified above.

Firstly, client generate a premaster_secret and encrypt it use RSA:

```
premaster_secret = [0...47]
temp = RSA(server_public_key, premaster_secret)
```

client send `temp` to server, then server decrypt temp to get premaster_secret:

```
premaster_secret = RSA_decrypt(server_private_key, temp)
```

2. ECDHE_RSA

This key exchange algorithm is the same as ECDHE_ECDSA except that the server's certificate MUST contain an RSA public key authorized for signing, and that the signature in the ServerKeyExchange message must be computed with the corresponding RSA private key.  The server certificate MUST be signed with RSA
First sever send ECDH parameters in certificate or server_key_exchange message.

- curve type
- public key
- signature


#### master secret

**client and server generate the master_secret by him self.**

```
master_secret = PRF(pre_master_secret, "master secret", ClientHello.random + ServerHello.random)
```

The master secret is always exactly 48 bytes in length.

##### PRF

> pesudorandom function

https://tools.ietf.org/html/rfc5246#section-5

[An implementation of Java](https://android.googlesource.com/platform/libcore2/+/b5de22c2a7fbe35f0dc8d3585e4bd9aa0966fc90/luni/src/main/java/org/apache/harmony/xnet/provider/jsse/PRF.java)


### For this project 

> Number type in code

- u8 -> uint_8
- u16 -> uint_16
- uN -> uint_N

#### Number extension function

```kotlin
fun ByteBuffer.getU16(): Int = (get().toInt() and 0xFF shl 8) or (get().toInt() and 0xFF)

fun ByteBuffer.getU24(): Int =
    (get().toInt() and 0xFF shl 16) or (get().toInt() and 0xFF shl 8) or (get().toInt() and 0xFF)

fun ByteBuffer.getU32(): Int =
    (get().toInt() and 0xFF shl 24) or (get().toInt() and 0xFF shl 16) or (get().toInt() and 0xFF shl 8) or (get().toInt() and 0xFF)

fun ByteBuffer.putU8(value: Int) = run {
    put(value.toByte())
}

fun ByteBuffer.putU16(value: Int) = run {
    put((value shr 8 and 0xFF).toByte())
    put((value and 0xFF).toByte())
}

fun ByteBuffer.putU24(value: Int) = run {
    put((value shr 16 and 0xFF).toByte())
    put((value shr 8 and 0xFF).toByte())
    put((value and 0xFF).toByte())
}

fun ByteBuffer.putU32(value: Int) = run {
    put((value shr 24 and 0xFF).toByte())
    put((value shr 16 and 0xFF).toByte())
    put((value shr 8 and 0xFF).toByte())
    put((value and 0xFF).toByte())
}

fun InputStream.readU8() = read()

fun InputStream.readU16(): Int {
    return (read() and 0xFF shl 8) or (read() and 0xFF)
}

fun InputStream.readU24(): Int {
    return (read() and 0xFF shl 16) or (read() and 0xFF shl 8) or (read() and 0xFF)
}

fun InputStream.readU32(): Int {
    return (read() and 0xFF shl 24) or (read() and 0xFF shl 16) or (read() and 0xFF shl 8) or (read() and 0xFF)
}
```

## Reference

- https://ciphersuite.info/cs/
