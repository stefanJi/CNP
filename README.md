# CNP

> Computer Network Playground

# [NetUtility](./NetUtility)

A collection of network utilities code implement by cpp in OSX.

## Features

- [x] arp
- [x] ping
- [ ] nslookup

## Build
 
- `make`
- `make arp`
- `make ping`

## Run

`build/arp <ip>`

`build/ping <host> <ping times>`

# [TLSImpl](./TLSImpl)

A client program written in Kotlin that implements the TLS (v1.2) protocol.

## Target

Generate a master key by implement TLS handshake. And use the key to communicate with the server.

```
Client                                    Server

ClientHello       -------->
                                     ServerHello
                                    Certificate*
                              ServerKeyExchange*
                             CertificateRequest*
                  <--------      ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished          -------->
                              [ChangeCipherSpec]
                  <--------             Finished
Application Data  <------->     Application Data
```

## Client Flow

- [x] Client Hello
- [x] Client Key Exchange
- [x] Change Cipher Spec
- [ ] Finished

## Handle Server Flow Parse

- [x] Server Hello
- [x] Certificate
- [x] ServerKeyExchang
- [x] ServerHelloDone
- [x] ChangeCipherSpec
- [ ] Finished


## Term

### Secret

#### premaster secret

https://tools.ietf.org/html/rfc5246#section-7.4.7

There are two ways to generate premaster secret in `Client Key Exchange`:

With `Client Key Exchange` message, the premaster secret is set, either by direct transmission of the RSA-encrypted secret or by the transmission of Diffie-Hellman parameters that will allow each side to agree upon the same premaster secret.

1. RSA

When RSA is used for server authentication and key exchange, a 48-byte pre_master_secret is generated by the client, encrypted under the server's public key, and sent to the server.  The server uses its private key to decrypt the pre_master_secret.  Both parties then convert the pre_master_secret into the master_secret, as specified above.

Firstly, client generate a premaster_secret and encrypt it use RSA:

```
premaster_secret = [0...47]
temp = RSA(server_public_key, premaster_secret)
```

client send `temp` to server, then server decrypt temp to get premaster_secret:

```
premaster_secret = RSA_decrypt(server_private_key, temp)
```

2. ECDHE_RSA

This key exchange algorithm is the same as ECDHE_ECDSA except that the server's certificate MUST contain an RSA public key authorized for signing, and that the signature in the ServerKeyExchange message must be computed with the corresponding RSA private key.  The server certificate MUST be signed with RSA.

First sever send ECDH parameters in certificate or server_key_exchange message.

- curve type: curve algorithm type
- public key: public key for DH
- signature: signature for verify server's DH public key, client use server's RSA public key in certificate and signature to verify DH public key

Then client will generate a DH public key to curve algorithm, send the public key to server:

```
client_public_key, client_private_key = ECDH(curve_algorithm)
```

client and server generate the premaster_secret by him self.

```
premaster_secret = ECDH_Key_Agreement(private, public)
```

Agreement parameters:

|side|private|public|
|:---|:---|:---|
|client|client private key| server public key|
|server|server private key| client public key|

#### master secret

client and server generate the master_secret by him self.

```
master_secret = PRF(pre_master_secret, "master secret", ClientHello.random + ServerHello.random)
```

The master secret is always exactly 48 bytes in length.

##### PRF

> pesudorandom function

https://tools.ietf.org/html/rfc5246#section-5

### Finished Message

```
finished_message_data = RPF(master_secret, finished_label, hash(handshake_message))
```

- finished_label: `client finished` or `server finished`
- handshake_message: All of the data from all messages in this handshake (not including any HelloRequest messages) up to, but not including, this message. This is only data visible at the handshake layer and does not include record layer headers

### Final Verify

On the end of handshake, server and client will verify the Finished Message to check the master_secret.
